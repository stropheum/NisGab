using System.IO;
using System.Linq;
using System.Text;
using UnityEditor;
using UnityEngine;
using UnityEngine.InputSystem;
using UnityEngine.InputSystem.Utilities;

namespace Editor.NisGab
{
    internal static class InputActionGenerator
    {
        private const string ContextMenuName = "Assets/Generate Input Action Binding";
        private const string OutputNamespace = "NisGab";

        private const string Header =
            "//------------------------------------------------------------------------------\n" +
            "// <auto-generated>\n" +
            "//     This code was auto-generated by NisGab's code generation tooling\n" +
            "//     from Assets/Config/InputSystemActions.inputactions\n" +
            "//\n" +
            "//     Changes to this file may cause incorrect behavior and will be lost if\n" +
            "//     the code is regenerated.\n" +
            "// </auto-generated>\n" +
            "//------------------------------------------------------------------------------\n\n\n";


        [MenuItem(ContextMenuName)]
        public static void GenerateInputActionCode()
        {
            var selectedObject = Selection.activeObject as InputActionAsset;
            if (selectedObject == null)
            {
                Debug.LogError("Must select an InputActionAsset to generate input action code");
                return;
            }

            GenerateCodeFromAsset(selectedObject);
        }

        [MenuItem(ContextMenuName, true)]
        private static bool ValidateGenerateInputActionCode()
        {
            return Selection.activeObject is InputActionAsset;
        }

        private static void GenerateCodeFromAsset(InputActionAsset selectedObject)
        {
            string targetDirectory = GetTargetDirectory(selectedObject);
            if (Directory.Exists(targetDirectory))
            {
                string[] files = Directory.GetFiles(targetDirectory, "*.*", SearchOption.AllDirectories);
                foreach (string file in files)
                {
                    File.Delete(file);
                }
            }
            
            ReadOnlyArray<InputActionMap> inputActionMaps = selectedObject.actionMaps;
            foreach (InputActionMap inputActionMap in inputActionMaps)
            {
                GenerateInputActionClass(inputActionMap, targetDirectory);
            }

            GenerateInputEventClass(inputActionMaps, targetDirectory);
        }

        private static void GenerateInputEventClass(
            ReadOnlyArray<InputActionMap> inputActionMaps, string targetDirectory)
        {
            StringBuilder sb = new();
            
            sb.Append(Header);
            sb.AppendLine("namespace " + OutputNamespace);
            sb.AppendLine("{");
            sb.AppendLine("\tpublic class InputEvent : UnityCodeExtensions.LazySingleton<InputEvent>");
            sb.AppendLine("\t{");
            foreach (InputActionMap inputActionMap in inputActionMaps)
            {
                string mapName = inputActionMap.name;
                sb.AppendLine("\t\tpublic static " + mapName + "InputActions " + mapName + " { get; private set; } = new();");
            }

            sb.AppendLine("");
            sb.AppendLine("\t\tprivate InputSystemActions _inputSystemActions;");
            sb.AppendLine("");
            sb.AppendLine("\t\tprotected override void Awake()");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tbase.Awake();");
            sb.AppendLine("\t\t\tInitialize();");
            sb.AppendLine("\t\t}");
            sb.AppendLine("");
            sb.AppendLine("\t\tprivate void OnDestroy()");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tUnInitialize();");
            sb.AppendLine("\t\t}");
            sb.AppendLine("");

            foreach (InputActionMap inputActionMap in inputActionMaps)
            {
                string mapName = inputActionMap.name;
                sb.AppendLine("\t\tpublic void Enable" + mapName + "Input()");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t    if (_inputSystemActions." + mapName + ".enabled) { return; }");
                sb.AppendLine("\t\t    _inputSystemActions." + mapName + ".Enable();");
                sb.AppendLine("\t\t}");
                sb.AppendLine("");
                sb.AppendLine("\t\tpublic void Disable" + mapName + "Input()");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\tif (!_inputSystemActions." + mapName + ".enabled) { return; }");
                sb.AppendLine("\t\t\t_inputSystemActions." + mapName + ".Disable();");
                sb.AppendLine("\t\t}");
                sb.AppendLine("");
            }

            sb.AppendLine("\t\tprivate void Initialize()");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\t_inputSystemActions = new InputSystemActions();");
            foreach (InputActionMap inputActionMap in inputActionMaps)
            {
                string mapName = inputActionMap.name;
                sb.AppendLine("\t\t\t" + mapName + ".Bind(_inputSystemActions." + mapName + ");");
            }

            sb.AppendLine("\t\t}");
            sb.AppendLine("");
            sb.AppendLine("\t\tprivate void UnInitialize()");
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tif (_inputSystemActions == null) { return; }");
            foreach (InputActionMap inputActionMap in inputActionMaps)
            {
                string mapName = inputActionMap.name;
                sb.AppendLine("\t\t\t" + mapName + ".UnBind(_inputSystemActions." + mapName + ");");
            }

            sb.AppendLine("\t\t}");
            sb.AppendLine("\t}");
            sb.Append("}");

            if (!Directory.Exists(targetDirectory)) { Directory.CreateDirectory(targetDirectory); }

            string filePath = Path.Combine(targetDirectory, "InputEvent.cs");

            File.WriteAllText(filePath, sb.ToString().Replace("\r\n", "\n"), Encoding.UTF8);
            AssetDatabase.Refresh();
        }

        private static void GenerateInputActionClass(InputActionMap inputActionMap, string targetDirectory)
        {
            string mapName = inputActionMap.name;
            string classString = GenerateClassString(inputActionMap);
            string filePath = Path.Combine(targetDirectory, mapName + "Inputactions.cs");
            if (!Directory.Exists(targetDirectory)) { Directory.CreateDirectory(targetDirectory); }

            File.WriteAllText(filePath, classString.Replace("\r\n", "\n"), Encoding.UTF8);
            AssetDatabase.Refresh();
        }

        private static string GenerateClassString(InputActionMap inputActionMap)
        {
            string mapName = inputActionMap.name;
            ReadOnlyArray<InputAction> actions = inputActionMap.actions;
            StringBuilder sb = new();
            sb.Append(Header);
            sb.AppendLine("using System;");
            sb.AppendLine("using UnityEngine.InputSystem;\n");
            sb.AppendLine("namespace " + OutputNamespace);
            sb.AppendLine("{");
            sb.AppendLine("\t/// <summary>");
            sb.AppendLine("\t/// Simple event container for " + mapName + " actions");
            sb.AppendLine("\t/// </summary>");
            sb.AppendLine("\tpublic class " + mapName + "InputActions");
            sb.AppendLine("\t{");

            foreach (InputAction action in actions)
            {
                sb.AppendLine("\t\tpublic event Action<InputAction.CallbackContext> " + action.name + ";");
            }

            sb.AppendLine("");
            sb.AppendLine("\t\tinternal void Bind(InputSystemActions." + mapName + "Actions actions)");
            sb.AppendLine("\t\t{");

            foreach (string actionName in actions.Select(action => action.name))
            {
                sb.AppendLine("\t\t\tactions." + actionName + ".performed += On" + actionName + ";");
            }

            sb.AppendLine("\t\t}");
            sb.AppendLine("");
            sb.AppendLine("\t\tinternal void UnBind(InputSystemActions." + mapName + "Actions actions)");
            sb.AppendLine("\t\t{");

            foreach (InputAction action in actions)
            {
                string actionName = action.name;
                sb.AppendLine("\t\t\tactions." + actionName + ".performed -= On" + actionName + ";");
            }

            sb.AppendLine("\t\t}");

            foreach (InputAction action in actions)
            {
                string actionName = action.name;
                sb.AppendLine("");
                sb.AppendLine("\t\tprivate void On" + actionName + "(InputAction.CallbackContext context)");
                sb.AppendLine("\t\t{");
                sb.AppendLine("\t\t\t" + actionName + "?.Invoke(context);");
                sb.AppendLine("\t\t}");
            }

            sb.AppendLine("\t}");
            sb.Append("}");

            return sb.ToString();
        }

        private static string GetTargetDirectory(InputActionAsset selectedObject)
        {
            Debug.Assert(selectedObject != null, "Selected InputActionAsset is null.");
            string assetPath = AssetDatabase.GetAssetPath(selectedObject);
            Debug.Assert(!string.IsNullOrEmpty(assetPath), "Could not find asset path for the selected InputActionAsset.");
            string directory = Path.GetDirectoryName(assetPath);
            Debug.Assert(!string.IsNullOrEmpty(directory), "Could not determine directory for the selected InputActionAsset.");
            Debug.Log("Generated files in directory: " + Path.Combine(directory, "Scripts", "Generated"));
            return Path.Combine(directory, "Generated");
        }
    }
}